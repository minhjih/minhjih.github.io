<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[minji]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>minji</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 08 Apr 2024 11:16:09 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 08 Apr 2024 11:15:58 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[중간고사 기출]]></title><description><![CDATA[ 
 <br>2021<br>
<br><a data-tooltip-position="top" aria-label="L2. Recall C (Part 1) > Call by Value &amp; Call by Reference" data-href="L2. Recall C (Part 1)#Call by Value &amp; Call by Reference" href="micro-processor\l2.-recall-c-(part-1).html#Call_by_Value_&amp;_Call_by_Reference" class="internal-link" target="_self" rel="noopener">Difference of Call by value and Call by reference</a>
<br><a data-tooltip-position="top" aria-label="L3. Recall C (Part 2) > Function &amp; Void Pointer" data-href="L3. Recall C (Part 2)#Function &amp; Void Pointer" href="micro-processor\l3.-recall-c-(part-2).html#Function_&amp;_Void_Pointer" class="internal-link" target="_self" rel="noopener">Meaning of void pointer on int example</a>.
<br><a data-tooltip-position="top" aria-label="L5. Recall C (Part 4) > Circular queue를 이용하는 이유" data-href="L5. Recall C (Part 4)#Circular queue를 이용하는 이유" href="micro-processor\l5.-recall-c-(part-4).html#Circular_queue를_이용하는_이유" class="internal-link" target="_self" rel="noopener">Advantage of Circular queue</a>
<br><a data-tooltip-position="top" aria-label="L9. ARM Cortex-M0(+) Core (Part 2) > Subroutine call" data-href="L9. ARM Cortex-M0(+) Core (Part 2)#Subroutine call" href="micro-processor\l9.-arm-cortex-m0(+)-core-(part-2).html#Subroutine_call" class="internal-link" target="_self" rel="noopener">The reaon why people use LR</a>
<br><a data-tooltip-position="top" aria-label="L10. C in Assembly Language > Register use convention" data-href="L10. C in Assembly Language#Register use convention" href="micro-processor\l10.-c-in-assembly-language.html#Register_use_convention" class="internal-link" target="_self" rel="noopener">How to send function Argument</a>
<br><a data-tooltip-position="top" aria-label="L8. ARM Cortex-M0(+) Core (Part 1) > ^efd2d5" data-href="L8. ARM Cortex-M0(+) Core (Part 1)#^efd2d5" href="micro-processor\l8.-arm-cortex-m0(+)-core-(part-1).html#^efd2d5" class="internal-link" target="_self" rel="noopener">Essential explanation of Program Counter</a>
<br><a data-tooltip-position="top" aria-label="L11. Arithmetic for computers (Part 1) > Two's complement" data-href="L11. Arithmetic for computers (Part 1)#Two's complement" href="micro-processor\l11.-arithmetic-for-computers-(part-1).html#Two's_complement" class="internal-link" target="_self" rel="noopener">How to check overflows generated by 2's complement binary addition</a>
<br><a data-tooltip-position="top" aria-label="L10. C in Assembly Language > ^ea2a2c" data-href="L10. C in Assembly Language#^ea2a2c" href="micro-processor\l10.-c-in-assembly-language.html#^ea2a2c" class="internal-link" target="_self" rel="noopener">The role of Assembler</a>
<br>2022<br>
<br><a data-tooltip-position="top" aria-label="L2. Recall C (Part 1) > Call by Value &amp; Call by Reference" data-href="L2. Recall C (Part 1)#Call by Value &amp; Call by Reference" href="micro-processor\l2.-recall-c-(part-1).html#Call_by_Value_&amp;_Call_by_Reference" class="internal-link" target="_self" rel="noopener">Describe the concept of “call by reference” scheme. You may provide a proper example in C language. (10)</a>]
<br><a data-tooltip-position="top" aria-label="L5. Recall C (Part 4) > Queue" data-href="L5. Recall C (Part 4)#Queue" href="micro-processor\l5.-recall-c-(part-4).html#Queue" class="internal-link" target="_self" rel="noopener">Implement a FIFO</a> by using two stacks. You have to define at least two functions for basic FIFO operations, each of which is described with <a data-tooltip-position="top" aria-label="L5. Recall C (Part 4) > Terminologies &amp; Operation" data-href="L5. Recall C (Part 4)#Terminologies &amp; Operation" href="micro-processor\l5.-recall-c-(part-4).html#Terminologies_&amp;_Operation" class="internal-link" target="_self" rel="noopener">basic stack operations.</a> (10)
<br><a data-tooltip-position="top" aria-label="L6. Recall C (Part 5)" data-href="L6. Recall C (Part 5)" href="micro-processor\l6.-recall-c-(part-5).html" class="internal-link" target="_self" rel="noopener">Describe any sorter algorithm faster than the conventional bubble sorting method. You need to conceptually provide the reason for reducing the processing time. (10)</a>
<br><a data-tooltip-position="top" aria-label="L8. ARM Cortex-M0(+) Core (Part 1) > Register" data-href="L8. ARM Cortex-M0(+) Core (Part 1)#Register" href="micro-processor\l8.-arm-cortex-m0(+)-core-(part-1).html#Register" class="internal-link" target="_self" rel="noopener">Describe one advantage and one disadvantage for reserving a general-purposed register to keep the address of stack pointer, e.g., R13 (SP) in ARMv6M architecture. (10)</a>
<br><a data-tooltip-position="top" aria-label="L8. ARM Cortex-M0(+) Core (Part 1) > Endianness" data-href="L8. ARM Cortex-M0(+) Core (Part 1)#Endianness" href="micro-processor\l8.-arm-cortex-m0(+)-core-(part-1).html#Endianness" class="internal-link" target="_self" rel="noopener">Describe the little-endian data stored in the memory with proper example. (10)</a>
<br><a data-tooltip-position="top" aria-label="L9. ARM Cortex-M0(+) Core (Part 2) > Conditional Branch" data-href="L9. ARM Cortex-M0(+) Core (Part 2)#Conditional Branch" href="micro-processor\l9.-arm-cortex-m0(+)-core-(part-2).html#Conditional_Branch" class="internal-link" target="_self" rel="noopener">Describe the functionality of branch-type instructions. Why do we have to define this instruction type? (10)</a>
<br><a data-tooltip-position="top" aria-label="L9. ARM Cortex-M0(+) Core (Part 2) > ^21fd5a" data-href="L9. ARM Cortex-M0(+) Core (Part 2)#^21fd5a" href="micro-processor\l9.-arm-cortex-m0(+)-core-(part-2).html#^21fd5a" class="internal-link" target="_self" rel="noopener">Describe the functionality of NOP instruction. Why do we have to define this instruction? (10)</a>
<br><a data-tooltip-position="top" aria-label="L10. C in Assembly Language > Prolog and Epilog" data-href="L10. C in Assembly Language#Prolog and Epilog" href="micro-processor\l10.-c-in-assembly-language.html#Prolog_and_Epilog" class="internal-link" target="_self" rel="noopener">Describe the essential prolog steps during the procedure call scenario. (10)</a>
<br><a data-tooltip-position="top" aria-label="L11. Arithmetic for computers (Part 1) > Sign/Maagnitude" data-href="L11. Arithmetic for computers (Part 1)#Sign/Maagnitude" href="micro-processor\l11.-arithmetic-for-computers-(part-1).html#Sign\Maagnitude" class="internal-link" target="_self" rel="noopener">How can we support a valid addition of two 32b signed-magnitude binary numbers by using the conventional 32b ripple-carry adder? Show a proper (C-like) pseudo code to describe your processing steps. (10)</a>
<br><a data-tooltip-position="top" aria-label="L12. Arithmetic for computers (Part 2) > Floating Point Standard" data-href="L12. Arithmetic for computers (Part 2)#Floating Point Standard" href="micro-processor\l12.-arithmetic-for-computers-(part-2).html#Floating_Point_Standard" class="internal-link" target="_self" rel="noopener">What is the main advantage of the normalized form to represent a floating-point number? (10)</a>
<br>2023<br>
<br><a data-tooltip-position="top" aria-label="L3. Recall C (Part 2) > Macros &amp; Preprocessing" data-href="L3. Recall C (Part 2)#Macros &amp; Preprocessing" href="micro-processor\l3.-recall-c-(part-2).html#Macros_&amp;_Preprocessing" class="internal-link" target="_self" rel="noopener">pre-defined function이 무엇인가, 그 예시를 드시오.</a>
<br><a data-tooltip-position="top" aria-label="L2. Recall C (Part 1) > Call by Value &amp; Call by Reference" data-href="L2. Recall C (Part 1)#Call by Value &amp; Call by Reference" href="micro-processor\l2.-recall-c-(part-1).html#Call_by_Value_&amp;_Call_by_Reference" class="internal-link" target="_self" rel="noopener">call by value와 call by reference의 차이를 서술하시오.</a>
<br><a data-tooltip-position="top" aria-label="L4. Recall C (Part 3) > Singly Linked List" data-href="L4. Recall C (Part 3)#Singly Linked List" href="micro-processor\l4.-recall-c-(part-3).html#Singly_Linked_List" class="internal-link" target="_self" rel="noopener">singly linked list와 doubly linked list의 차이를 서술하시오</a>
<br><a data-tooltip-position="top" aria-label="L5. Recall C (Part 4) > Stack" data-href="L5. Recall C (Part 4)#Stack" href="micro-processor\l5.-recall-c-(part-4).html#Stack" class="internal-link" target="_self" rel="noopener">stack의 기본 함수로 enqueue를 구현할 수 있는가? 어떻게 하면 되는가? (간단한 코드와 함께)</a>
<br><a data-tooltip-position="top" aria-label="L6. Recall C (Part 5) > Shell Sort" data-href="L6. Recall C (Part 5)#Shell Sort" href="micro-processor\l6.-recall-c-(part-5).html#Shell_Sort" class="internal-link" target="_self" rel="noopener">shell sort를 queue를 통해 구현하시오. (간단한 코드와 함께)</a>
<br><a data-tooltip-position="top" aria-label="L10. C in Assembly Language" data-href="L10. C in Assembly Language" href="micro-processor\l10.-c-in-assembly-language.html" class="internal-link" target="_self" rel="noopener">CPU가 instruction을 수행하는 과정을 서술하시오.</a>
<br><a data-tooltip-position="top" aria-label="L10. C in Assembly Language > Register use convention" data-href="L10. C in Assembly Language#Register use convention" href="micro-processor\l10.-c-in-assembly-language.html#Register_use_convention" class="internal-link" target="_self" rel="noopener">기억 잘 안나는데 그냥 function call &amp; return 어떤 식으로 하는지? 뭐 이런 거였음</a>
<br><a data-tooltip-position="top" aria-label="L12. Arithmetic for computers (Part 2) > ^561833" data-href="L12. Arithmetic for computers (Part 2)#^561833" href="micro-processor\l12.-arithmetic-for-computers-(part-2).html#^561833" class="internal-link" target="_self" rel="noopener">IEEE Std 754에 의하면 어떻게 Floating point number를 정의하는가?</a>
<br>ARM cortex M0+ architecture에서 overhead를 어떻게 표현하는가?
<br><a data-tooltip-position="top" aria-label="L12. Arithmetic for computers (Part 2) > Floating Point Addtion" data-href="L12. Arithmetic for computers (Part 2)#Floating Point Addtion" href="micro-processor\l12.-arithmetic-for-computers-(part-2).html#Floating_Point_Addtion" class="internal-link" target="_self" rel="noopener">4-digit binary number의 floating-point addition 과정을 서술하라.</a>
]]></description><link>micro-processor\중간고사-기출.html</link><guid isPermaLink="false">Micro processor/중간고사 기출.md</guid><pubDate>Mon, 08 Apr 2024 11:13:07 GMT</pubDate></item><item><title><![CDATA[Curiosity]]></title><description><![CDATA[ 
 <br>
<br><a data-tooltip-position="top" aria-label="L2. Recall C (Part 1) > Various Data Types" data-href="L2. Recall C (Part 1)#Various Data Types" href="micro-processor\l2.-recall-c-(part-1).html#Various_Data_Types" class="internal-link" target="_self" rel="noopener">int type과 long type의 사이즈</a>
<br><a data-tooltip-position="top" aria-label="L5. Recall C (Part 4) > Dynamic Array Based Implementation" data-href="L5. Recall C (Part 4)#Dynamic Array Based Implementation" href="micro-processor\l5.-recall-c-(part-4).html#Dynamic_Array_Based_Implementation" class="internal-link" target="_self" rel="noopener">Dynamic array의 연산량을 줄이는 방법, 평균적으로 O(1)인 이유</a>
<br><a data-tooltip-position="top" aria-label="L6. Recall C (Part 5) > ^75b155" data-href="L6. Recall C (Part 5)#^75b155" href="micro-processor\l6.-recall-c-(part-5).html#^75b155" class="internal-link" target="_self" rel="noopener">Worst case Space Complexity</a>
<br><a data-tooltip-position="top" aria-label="L6. Recall C (Part 5) > Quick Sort" data-href="L6. Recall C (Part 5)#Quick Sort" href="micro-processor\l6.-recall-c-(part-5).html#Quick_Sort" class="internal-link" target="_self" rel="noopener">Worst case space complexity는 어떻게 optimize가 가능할까?</a>
<br><a data-tooltip-position="top" aria-label="L11. Arithmetic for computers (Part 1) > Fast Multiplier" data-href="L11. Arithmetic for computers (Part 1)#Fast Multiplier" href="micro-processor\l11.-arithmetic-for-computers-(part-1).html#Fast_Multiplier" class="internal-link" target="_self" rel="noopener">Faster Multiplier</a>에서 제대로 연산이 안되는 문제가 생김
<br>
]]></description><link>micro-processor\curiosity.html</link><guid isPermaLink="false">Micro processor/Curiosity.md</guid><pubDate>Mon, 08 Apr 2024 07:13:02 GMT</pubDate></item><item><title><![CDATA[L2. Recall C (Part 1)]]></title><description><![CDATA[ 
 <br><br><br>printf: 결과 출력 함수.<br>int main(void){
	printf("hello,world");
}
Run복사<br>위의 경우 hello,world를 출력 시킴. <br><br>scanf: 입력 함수<br>int main(void){
	int result;
	scanf("%d", &amp;result);
	printf()
}
Run복사<br>위에서 보이듯이, console로 부터 입력을 받아오는 경우, 주소 값을 통하여 접근 해줘야한다.<br>scanf("%d", reulst); //X, 이 같은 경우 값이 저장되지 않음 
scanf("%d", &amp;reulst);//O, 옳은 방식
Run복사<br><br><br>true condition동안 반복한다. for 함수에는 3개의 입력이 들어가는데,<br>for (initial value, condition, modification on the condition)
Run복사<br>이 순서로 들어가게 된다. <br><br>마찬가지로 true condition동안 반복한다. <br>while(condition){
modification on the condition;
}
Run복사<br>위와 같은 방식으로 while문을 탈출한다.<br><br>While문과 유사하게 되어있지만, do문에서 한번 조건을 실행한 후에 while문의 조건을 따르는 것을 확인할 수 있다.<br>do{
//반복할 행동;
}while(i &lt; 0); //여기에 따옴표 놓치지 말기를
Run복사<br><br><br>int a;
scanf("%d", &amp;a);
if(a == 0){
	printf("a is zero\n");
}else if(a &gt; 0){
	printf("a is positive\n");
}else{
	printf("a is negative\n")
}
Run복사<br>a가 0인 경우에는 a is zero을 출력, a가 양수인 경우에는 a is positive를 출력, a가 음수인 경우에는 a is negative를 출력한다. 따라서 조건을 나누는 데에 if문을 사용한다.<br><br>switch는 조금 독특한 특성을 가지고 있다. 먼저 조건에 따라 switch를 통해 결과를 다르게 할 수 있다. 하지만 아래 두 경우를 보자.<br>int gpa;
switch(gpa){
	case 0:
		printf("F\n");
	case 1:
		printf("D\n");
	//...
	case 4:
		printf("A\n");
		printf("Good job!\n");
	default:
		printf("Wrong\n");
}
Run복사<br>이 경우에 gpa 변수에 0 이 들어갔다고 생각해보자. 우리가 예상할 수 있는 결과 값으로 보아 출력이 F\n 로 나타나야 할 것만 같지만, switch의 특성 때문에 결과는 F\nD\nA\nGood job!\nWrong\n과 같은 모든 경우의 printf 함수가 실행이 되는 것을 확인할 수 있다. switch는 조건이 한번 실행된다면 그 아래에 작성된 조건들도 true값을 지니고 있어, 이를 벗어 나기 위해서는 break 를 사용해야 한다.<br>
따라서, 수정된 코드를 보면 아래와 같다.<br>switch(gpa){
	case 0:
		printf("F\n");
		break;
	case 1:
		printf("D\n");
		break;
	//...
	case 4:
		printf("A\n");
		printf("Good job!\n");
		break;
	default:
		printf("Wrong\n");
		break; //default part의 break문은 사실 필요 없다
}
Run복사<br>
break와 continue는 무엇인가?
<br>break는 반복문의 괄호를 탈출할 수 있는 역할을 한다.  Branch condition을 벗어나는 경우(switch), Loop function.<br>
비슷한 친구로 continue가 있다. 이 코드는 아래 부분의 명령어를 무시한다.<br>
break와 continue의 행동은 굉장히 직관적이기 때문에 필요에 따라 사용하지만, 필요 이상의 break와 continue는 쉽게 spaghetti code를 만들기 때문에 문제가 생기기 쉽다.<br><br>data type은 hardware depend한 경우도 굉장히 많다. 대표적인 예시로 int type의 경우 hardware에서 가장 효율적으로 사용할 수 있는 정수형 타입임에도 불구하고 64bit 컴퓨터에서도 32bit의 데이터 사이즈를 가진다. 그러니 그냥 표에 있는 대로 외우자<br><br>특이한 점은 long은 int의 두 배의 Size 를 가지지만, 범위가 같다는 것이다. 이는 Data bus의 한계로  같은 값을 가지는 게 아닌가 추측해 봄.<br><br>
Integer
<br>Integer의 경우에는 2's complement 방식으로 저장을 한다. 2의 보수에 1을 더해 수를 구성한다. -&gt; overflow가 나는 경우도 있음.<br>
Real number
<br>실수와 정수는 그 개수가 다르기 때문에 위와 같은 방법으로 mapping하게 된다면, 그 수를 표현할 수 없을 것이다. 따라서 IEEE-754라는 Binary Floating point Arithmetic을 사용한다. <br>module 32_standard(
	reg [31] Sign,
	reg [30:23] Exponent,
	reg [22:0] Mantissa
); //(1, 8, 23)

module 64_standard(
	reg [63] Sign,
	reg [62: 52] Exponent,
	reg [51: 0] Mantissa
	//(1, 11, 52)
);
복사<br>위의 방식은 Big endian으로 표현한 것이다. 여기서 Sign은 부호를 Mantissa는 부동 소수점까지 정수를 표현하는데, Exponenet는 어떤 식으로 작동할까.<br>
32 bit float 변수를 나타내기 위해서는 위와 같이 표현할 수 있게 된다.<br><br>To use Memory space efficiently boolean express<br>
ex).  boolean {0,1}에 int를 할당하면 너무 큰 손실이 생긴다.<br>
그렇다고 항상 fit한 것이 좋은가?<br>
아니다. 가장 빠른 data type은 int다. 처음에 잠깐 언급했지만, hardware에서 가장 효율적으로 사용할 수 있는 정수형 타입을 int로 정의한다고 했다. 이는 CPU에서 주로 32-bit로 쓰이기 때문인데, CPU에서 이뤄져 있는 DATA buss나 path가 주로 32bit로 이뤄져 있기 때문에 int type이 가장 빠른 것이라 볼 수 있다.<br>
ex). 64bit computer에선 float보다 double이 빠르다.<br><br>Return size of data type<br>
컴퓨터에 따라 데이터의 size가 다르기 때문에, sizeof를 통하여 체크 해줄 수 있다.<br><br>casting은 기존의 데이터 타입을 다른 데이터 타입으로 변경 시켜주는 과정이다.<br>
ex). double -&gt; int <br>double a = 3.14;
int b = 6;
printf("%f\n", (double)((int)a + b));
//9.000000
Run복사<br><br><br><br>Example<br><br><br>Function의 요소에는 Return type, function name arguements가 있다.<br>int add (int i, int j){
//return type: int, Name of a function: add, Arguements: i, j
	/*Body of the function*/
	int result;
	result = i+j;
	/*Body of the function*/
	return result; //Return value = result
}
Run복사<br>미리 정의된 함수의 경우에는 어떤 식으로 동작할까?<br>predefined function은 1. function call을 이용해서 함수의 주소로 이동하여, 2.함수 동작 수행 후, 3. return value 반환<br>하지만, 함수는 procedual한 절차를 따라야함.-&gt; 따라서, procedual하게 정의를 미리 해줘야 한다. <br>#include &lt;stdio.h&gt;
int add(int a, int b); //함수 틀만 미리 제공함으로써 컴파일 에러 방지

int main(void){
	int d;
	d = add(3, 4); 
	printf("%d\n", d);
	return 0;
}

int add(int a, int b){
	int result = i + j;
	return result;
}
Run복사<br><br>
Local variable
<br>Local variable은  { }사이에 정의되어, { } 안에서만 접근 가능하다.<br>
Global variable
<br>{ }에 의해서 정의되는 것이 아니기 때문에, 아무 곳에서 접근 가능하다. 함수 전역에 영향을 미칠 수 있음.<br>어떻게 local 변수와 Global 변수가 사용이 가능한 것일까?<br>
Local 변수의 경우에는 { }밖을 벗어나게 되면 1. stack을 통해 저장되던, 2. 삭제되던 둘 중 하나.<br>
<br>Function call을 통해 다른 곳으로 이동하게 될 때.
<br>{} 끝나고, fp가 다시 불려 왔을 때
<br><br>재귀 함수: 함수에서 자기 자신을 호출함. 나가는 조건이 존재하지 않으면 Explosion함.<br><br><br>
Definition
<br>같은 종류의 변수를 가진 리스트 혹은 셋.<br>int array[10]; //초반에 사이즈를 지정해주어야함.
printf(%d, sizeof(array)); //40 byte (4byte * 10)

//initialization
int array1[10] = {}; //0으로 초기화
int array2[10] = {1,2,3,4,5,6,7,8,9,0}; //일반적으로.
int array3[]   = {1,2,3,4,5,6,7,8,9,0}; //자동으로 사이즈 결정해줌
Run복사<br>그 예시에는 String이 있다. String은 정확히는 Char의 list다. 따라서, array를 이용하여 string을 표현할 수 있다.<br>int main(void){
	char str1[5] = "Good"; // 큰따옴표를 썼을 땐 이미 string이기 때문에 \0이 끝에 숨겨짐
	char str2[] = "Morning"; // 7개가 들어가지만, null character포함 8 bytes.
	char str3[] = "Good\0abc"; // 일단 당연하게도 출력은 Good에서 멈춤. "" -&gt;string이기에 
							  // 마지막은 항상 null pointer들어가야함. size = 9bytes.
	return 0;
}
Run복사<br><br>
Definition
<br>Pointer는 주소를 저장하는 변수다.<br>int main(void){
	char c = 'a';    //&amp;c로 주소 접근 가능
	int n = 7;       //&amp;n로 주소 접근 가능
	double d = 3.14; //&amp;d로 주소 접근 가능
}
Run복사<br>Pointer의 size는 32bit computer에서는 4byte, 64bit 컴퓨터에서는 8byte로 나타난다. 어찌보면 이는 당연하지. 그렇다고 모든 주소 값이 그리 변한다는 것은 아니고, char의 경우에는 1bit, double의 경우에는 8byte씩 이동.<br>주의사항!! 포인터는 할당되지 않은 주소로 접근이 안된다.<br>int main (void){
int* PA1;
*PA1 =10; //ERROR!! PA는 깡통 address들어가 있음 접근 권한 없음!

int* PA2 = 100; 
*PA = 10; //ERROR!! GCC에서 100번지 변경 허가 안함!
return 0;
}
Run복사<br><br>Array의 이름이 주소 값을 가지고 있다!<br>int a[5] = {0, 1, 2, 3, 4};
// a = 0x1000을 가지고 있다고 치면 0x1000은 0을 저장하고 있는 주소. 0x1004는 1, 0x1008은 2..
Run복사<br>Pointer와 Name of an array의 차이점은 아래와 같다.<br><br>Name of an Array는 변경되지 않는다.  Pointer가 아니기 때문에 아래와 같은 경우는 안된다.<br>int main(void)
{
	int a[5] = {1,2,3,4,5};
	int b = 10;
	a = &amp;b;//a 는 포인터 변수 아니라 불가능!
}
Run복사<br>하지만 그에 비하여 포인터는 variable로, 주소값 변경이 가능하고, 접근이 허용된 다른 주소를 접근할 수 있다.<br><br>
Pointer의 Size
<br>Pointer의 size는 Pointer변수가 담는 자료형에 따라 그 크기가 결정된다. int*는 4byte, char*은 1byte, double* 은 8byte로 이들을 따라간다.<br>그래서, 기본 덧셈 단위로 ++를 취해주게 되면, size of data만큼 증가하게 된다.<br>int* ptr1 = 0;
char* ptr2 = 0;
double* ptr3 = 0;
ptr1++;
ptr2++;
ptr3++;
printf("%d, %d, %d \n", ptr1, ptr2, ptr3); // 4, 1, 8 출력
Run복사<br>Name of array도 변경 불가능한 것 빼고는 pointer와 동작이 같다.<br>//arr[i]는 *(arr+i)로 표현 가능하다.
int arr[5] = {1,2,3,4,5};
int* pArr = arr;
printf("%d",*(pArr + 1)); //arr[1]
Run복사<br>앞서 말한 것 과 같이 string은 char의 array로 표현 가능하다. (자동으로 할당이 가능함.)<br>char str1[5] = "abcd";
char *str2 = "ABCD";// sizeof(char)*5 만큼 동일하게 표기가능

int a = 10; b = 20; c = 30;
int* arr[3] = {&amp;a, &amp;b, &amp;c}; //직접적으로 array를 매핑해준다.
char* str3[2] = {"Hello", "byebye"}; //위의것도 되기에 동일하게 이것도 가능
Run복사<br>Pointer도 또한 함수의 arguement로 사용이 가능하다. 메모리에서 직접 접근이 가능하도록 하기 때문에, call by value와 call by reference로 나눌 수 있다.<br><br>
Call by Value
<br>Call by Value는 변수의 값을 복사하여 불러오는 것을 의미한다.<br>
Call by reference
<br>Call by reference 는 주소 값을 통하여, 실제 메모리에 접근하여 변수의 데이터에 접근하는 것을 의미한다. ]]></description><link>micro-processor\l2.-recall-c-(part-1).html</link><guid isPermaLink="false">Micro processor/L2. Recall C (Part 1).md</guid><pubDate>Fri, 05 Apr 2024 06:42:48 GMT</pubDate></item><item><title><![CDATA[L3. Recall C (Part 2)]]></title><description><![CDATA[ 
 <br><br>Structure는 여러 variable들의 그룹으로 되어있는 새로운 변수의 type을 말한다.<br>struct point{
	int x;
	int y;
};

struct point{
	int x;
	int y;
}p1, p2, p3; //바로 정의

typedef struct point{
	int x;
	int y;
} point_name; //type def로 이름 지정
//...
int main(void){
	struct point p1, p2, p3;
	point_name p1;
	point_name pArray[3] = {{1, 2},
						   {2, 3},
						   {3, 4}}; //array initialize {}로 가능
	
	p1.x = 1; //. operatioin으로 접근 가능
	p1.y = 1;
Run복사<br><br>Pointer of a Structure도 정의할 수 있다.<br>struct person{
	char name[20];
	char phone[20];
};

int main(){
	struct person man = {"Thomas", "354-00xx"};
	struct person* pMan;
	pMan = &amp;man; //주소를 동일하게 만들어줌으로써 접근이 가능하도록 만들어줌

	//하지만!
	printf("name: %s\n phone: %s\n", man.name, man.phone); //dot operation으로 접근
	printf("name: %s\n phone: %s\n", (*pMan).name, (*pMan).phone); // 로 접근
	printf("name: %s\n phone: %s\n", pMan -&gt; name, pMan -&gt; phone); // pointer에서 접근
}
Run복사<br>Array와 비슷한 점이 많은데, structure의 첫 번째 element의 주소가 structure의 주소와 같다.<br>printf("address1: %d \naddress2: %d", &amp;man, &amp;(man.name))
// address1과 address2가 같은 결과를 낸다.
Run복사<br>structure 복사를 위해서 = operator를 이용할 수 있다.<br>struct person man = {"Thomas", "354-00xx"};
struct person this_man;

this_man = man; //내부의 값을 복사하는 역할을 한다.
Run복사<br><br>Structure는 정의에 따라서 변수 type임을 알 수 있다. 당연하게도 함수의 return type으로 사용될 수 있다. 뿐만 아니라, 구조체의 내부 변수로 구조체 타입을 사용할 수 있는데 이 경우에 initializing 기법이 굉장히 흥미롭다.<br>struct circle{
	struct point p; //with element int x, int y
	double radius;
}

//...
/*case 1*/
struct circle c = {1, 2, 3.0}; //x = 1, y = 2, radius = 3.0
/*case 2*/
struct circle c = {1, 2};      //x = 1, y = 2, radius = set as default, 0
/*case 3*/
struct circle c = {{1, 2}, 3.0} //same as case 1
/*case 4*/
struct circle c = {{1}, 3.0} // x = 1, y = set as default, 0, radius = 3.0
Run복사<br><br><br>1-D array와 다르게 array의 element로 array를 가지고 있는 것을 의미한다.<br>
ex). int arr[5][10]: 5행 10열의 Multi-D arrays<br>구조체의 초기화 <a data-tooltip-position="top" aria-label="Intializing Structure" data-href="#Intializing Structure" href="about:blank#Intializing_Structure" class="internal-link" target="_self" rel="noopener">예시</a>와 같이 initializing은 { }을 통하여 설정해줄 수 있다.<br>
Multi-D array의 경우에는 일렬의 array를 편의상 분할해 놓은것이기 때문에 일렬의 array로 생각하여 초기화 해주어도 된다.<br>int somang[3][3] = {1,2,3,4,5,6,7}; //나머지는 set as default.
int somang[3][3] = {{1},{2,3},{4,5,6}}; //나머지는 set as default.

/*빈 Braket으로 초기화*/
int somang[2][] = {1,2,3,4,5,6}; //불가능 ERROR!
int somang[][] = {1,2,3,4,5}; //불가능 ERROR!
int somang[][2] = {1,2,3,4,5,6}; //4*2 array 생성 -&gt; 무조건 뒤에부분 명시 해줘야함
Run복사<br>
(N&gt;2)-D Arrays
<br>당연히 N이 2보다 클 때에도 array를 생성할 수 있다. 비디오?<br>
Pointer of Pointer
<br>Double Pointer라고 불린다. 주소를 저장하는 주소를 저장하는 변수로써 역할을 한다. <br><br>1-D array에서 +1 operation이 array name에서 어떤 식으로 더해지는지 확인 해본 적이 있다. 마찬가지로, N-D array에선 어떨까.<br>int a[3][2] = {};
printf("address a: %d", a); //a의 주소 출력 == &amp;a[0][0]
printf("address a + 1: %d", a + 1); // a+1의 주소 출력 == &amp;a[1][0]
Run복사<br>즉, 8byte 간격으로 더해지기 때문에, 8만큼 증가하여 출력한다. <br>
Function Arguement
<br>Function Arguement로 Multi-D array가 들어가기 위해서는 어떻게 해야할까?<br>void function1(int (*a)[10]){ //int a[][10]
	//...
}

void function2(int (*a)[10][11]){ //int a[][10][11]
	//...
}

int main(void){
	int arr1[8][10];
	function1(arr1);

	int arr2[8][10][11];
	function1(arr2);
}
Run복사<br>위와 같이 되는 이유는 *a 가 a[] 을 의미하기 때문이다.<br><br>
Function Pointer
<br>변수 뿐만 아니라, 함수들도 메인 메모리에서 load 된다.<br>
function pointer도 변수로써 활용할 수 있다. 아래 예시를 통해서 확인해보자.<br>int a, b;
char c;
int (*fct)(int, int);

scanf("%d %c %d", &amp;a, &amp;c, &amp;b);
if(c == '+'){
	fct = add; //fct 설정 가능
}else if(c == '-'){
	fct = sub; //fct 설정가능
}else if(c == 'x'){
	fct = mul;
}else if(c == '/'){
	fct = div;
}
printf("%d %c %d = %f\n", a, c, b, fct(a, b));
Run복사<br>조건은 argument가 같아야 한다는 것. 같은 argument를 가졌다면 동일한 function pointer형태로 대체가 가능하다.<br>
Void Pointer
<br>Void Pointer는 그냥 형식이 없음. 주소를 담을 수는 있는데, 어떤 타입의 주소형인지 결정되기 전까지는 operation이 작동하지 않음.<br>int main(void){
	int n = 10;
	void* vp = &amp;n; //-&gt; 문제 없음
	/*Opperation 작동하지 않음*/
	*vp = 20; //ERROR! -&gt;여기서 부터 문제
	vp++; //ERROR! 
	
	/*Operation 작동시키려면*/
	*((int*)vp) = 20; //형식이 결정되기 때문에 가능!!
}
Run복사<br><br><br><br>Compile시에 필요한 Stack의 사이즈를 Compiler가 결정해버린다. 따라서, Stack에 저장되는 Array는 한번 선언되면 그 사이즈가 변경되기 힘들고, 입력에 따라 사이즈를 결정하는 과정은 허용하지 않는다.<br>//...
int arr[a]; //이런 방식의 할당은 허용하지 않는다.
Run복사<br>그래서, Stack Area가 아닌 Heap Area에 Array를 저장할 수 있도록 한다. <br>
Stack vs Heap
<br>Stack은 흔히 프로그램에 의해 자동으로 관리 되는 정적 할당영역이다.<br>
Heap은 프로그래머에 의해 관리되는 동적 할당 영역이다.<br><br>stdlib를 통해 함수 사용이 가능하다.<br>#include &lt;stdlib.h&gt;
/*malloc Allocate memory*/
int *arr = (int*)malloc(a * sizeof(int)); //int arr[a];를 대체 
int *arr = (int*)calloc(a, sizeof(int)); //int arr[a];를 대체, 0으로 초기화
//할당 해제!! **중요!!**
Run복사<br><br>
stream
<br>stream이란, data를 전송하고 수신하는 방법. 따라서, I/O stream이 있다.<br><br>File pointer를 먼저 만들어 주어야 한다.<br><br><br>
Text mode
<br>Text mode에서는 자동으로 텍스트 파일에서 줄 바꿈이 이뤄질 수 있게 변환해준다.<br>"ABC \rDEF" -&gt; "DEF" ABC 출력이후 Carage return으로 DEF 다시 덮어씀
"ABC \nDEF" -&gt; "ABC\
				   DEF" 이런식으로 써짐
"ABC \r\nDEF" -&gt;"ABC\
				 DEF" 딱 원하는 대로 써짐
Run복사<br>줄 바꿈 기호가 운영체제에 따라 다른 이유에 Text mode에서 자동으로 CR(Carriage return)과 LF(Line feed) 진행하여 줄 바꿔서 써준다.<br>
Binary mode
<br>Binary mode는 사실 txt 파일을 위한 것이 아니라 소리나 이미지 같은 것을 위한 것.<br><br>#include &lt;stdio.h&gt;

int main()
{
    FILE* file = fopen("test.txt", "wt");
    fputs("File I/O\n", file);
    fclose(file);
   
    char buf[30];
    FILE* file1 = fopen("test.txt", "rt");
    fgets(buf, sizeof(buf), file1); //buffer에 일시저장
    fputs(buf, stdout);//stdout 이라는 출력 stream에 넣는다.
    fclose(file1);
    return 0;
}
Run복사<br>파일에서 데이터를 출력하거나 가져오는 fprintf, fscanf가 있다.<br>
EOF?
<br>End of File이라는 뜻으로 파일이 끝나는 것을 의미한다. EOF = -1의 값을 가진다. 따라서 EOF의 값을 판단하는 방법은 EOF Flag가 생기거나 파일이 더 읽히지 않는 경우다.<br>
<br>fgetc(): EOF(-1)
<br>fgets(): NULL(0)
<br>fscanf(): EOF(-1)<br>
위의 세 개의 함수를 통해 확인 가능하다. 
<br>int main(){  
    int i, a, b, c;
    charbuf[30];  
    char* pState;  
    FILE* file = fopen("test.txt","rt");  
    while(1){  
        pState = fgets(buf, sizeof(buf), file);  //fgets의 함수 state를 계속해서 업데이트
        if(pState==NULL) //string이 안나와 NULL이 생김 
            break;  
        printf(buf);  
        
    }  
    fclose(file);  
    return0;  
}
Run복사<br>fgets의 경우에는 string을 가져오기 때문에 NULL의 경우 문제가 될 소지가 크게 없다. 하지만, fgetc와 fscanf의 경우에는 EOF를 통해 가져오기 때문에 문제가 생길 수 있는데...<br>#include &lt;stdio.h&gt;

int main(){
  char ch;
  FILE *file = fopen("test.txt", "rt");
  while(1){
      ch = fgetc(file);
	  if (ch == -1)
		break;
	  printf ("%c\n", ch);
    }
  fclose (file);
  return 0;
}
Run복사<br>위와 같이 ch를  char 자료형으로 설정 하였다면 fgetc를 통해 얻은 character중에 255 값을 가지는 ASCII 코드가 있을 것이다. 255가 character로 들어가게 된다면, casting이슈로 인하여, -1로 오표기 될 것이다. 따라서, 이를 방지 하기 위해서는 ch를 int형으로 설정하면 255가 음수로 표기되지 않는다.<br>
아니면, 그냥 feof라는 함수를 사용하자... -&gt; feof(file)<br>
feof(fiile)은 끝나지 않으면 0을 출력 끝나면 1 출력으로 예상.<br><br>컴파일 과정을 두 개로 나누면 1. 전처리 과정과 2. 컴파일 과정으로 나눌 수 있다.<br>
# define
<br>define의 경우에는 컴파일러가 아닌 preprocessor에 의하여 처리된다.<br>#include &lt;stdio.h&gt;
#define PI 3.14 
//위와 같이 define으로 PI값을 설정해줄 수 있다.
Run복사<br>
Macro function
<br>Macro function도 컴파일러가 아닌 preprocessor에 의해 정의되고, 간단한 함수를 정의할 수 있다.<br>#include &lt;stdio.h&gt;
#define Square(x) x*x
//위와 같이 define으로 MACRO를 pre define할 수 있다.
Run복사<br>주의 사항 !!<br>#define SQUARE(x) x*x
#define SQUARE_real(x) (x)*(x)
int main(){
	int a = 3;
	printf("%d\n", SQUARE(a+3)); //a + 3 * 3 + a = 15
	printf("%d\n", SQUARE_real(a+3)); //(a+3)*(a+3) = 36
}
Run복사<br>함수처럼 이용할 수 있긴 하지만, 값을 복사하여 이동하는 함수와 달리 Macro는 치환의 역할을 한다. 따라서, a+3 이 먼저 연산 되는 것이 아니라 치환됐던 것들을 원래대로 복귀한 뒤, 연산한다.<br>
따라서, 괄호를 이용하여 연산 순서를 지정해줄 수 있도록 해야 한다. ]]></description><link>micro-processor\l3.-recall-c-(part-2).html</link><guid isPermaLink="false">Micro processor/L3. Recall C (Part 2).md</guid><pubDate>Fri, 05 Apr 2024 11:56:46 GMT</pubDate></item><item><title><![CDATA[L4. Recall C (Part 3)]]></title><description><![CDATA[ 
 <br><br>Linked list는 데이터 구조로 data의 group을 저장하는 데에 사용된다.<br>
Properties
<br>
<br>연속적인 요소들은 포인터로 연결되어있다.
<br>마지막 요소는 NULL을 가리킨다.
<br>사이즈를 늘리거나 키울 수 있다.
<br>원하는 만큼 길게 만들 수 있다.
<br>메모리 공간을 낭비하지 않고, 크기가 커지면 메모리를 할당한다.
<br>
Operations
<br>Insert, Delete는 꼭 필요하다.<br><br>
Array의 장점 
<br>
<br>사용하기 간단하고 쉽다. 
<br>빠르게 Access할 수 있다.
<br>
Array의 단점
<br>
<br>memory낭비가 너무 심하다. (일렬로 해야 함)
<br>정해진 사이즈 때문에 고치기 힘들다.
<br>긴 경우에는 할당하기 힘들다.
<br>position based 삽입이 힘들다.
<br>
Dynamic array는?
<br>Fixed size에서 시작하는데, 여기서 더 커지거나 작아지거나 한다.<br>
보통 임계치에 다 다르면 두 배 몸집을 키운다. -&gt; memory 할당 과정 최소화<br>
마찬가지로 element개수가 절반 이하면 memory 줄인다.<br>
Advantage &amp; Disadvantage of Linked list
<br>장점: Append하는 데에 constant한 시간이 걸린다.<br>
단점: random-access property 없음.<br>
cache perfomance를 무시한다.<br>
조절하기 힘들 때가 있다.<br>
Reference를 위한 추가적인 공간을 필요로 한다.<br>아래는 Linked list, Array, Dynamic Array의 접근 시간을 Big-O notation으로 나타낸 것이다. 한번 확인해 보는 것이 좋을 듯 <br><br><br><br> 가장 간단한 형태.<br>struct ListNode{
	int data;
	struct ListNode *Next
};
Run복사<br> 구현 되어야 할 3가지 기능이 있다.<br><br>int ListLength(struct ListNode* head){
	struct ListNode* current = head;
	int count = 0;
	while(current != NULL){
		count++;
		currrent = current-&gt;next;
	}
	return current;
}
Run복사<br>위에서 보면 알겠지만, Scanning하는 데에 <br><br>다 필요 없고 노드 생성해서 붙이면 된다.<br>
Time complexity: O(n)<br>
Space Complexity: O(1) for each node<br><br>Time complexity: O(n)<br>
Space Complexity: O(1)<br><br>양옆으로 이어진 형태의 linked list<br>struct DLLNode{
	int data;
	struct DLLNode *prev;
	struct DLLNode *next;
};
Run복사<br>
Advantage
<br>주어진 노드에 대하여 두 방향으로 나아갈 수 있다.<br>
위의 이유로 인하여 Deletion이 훨씬 수월해진다.<br>
Disadvantage
<br>
<br>각 Node는 추가적인 포인터를 필요로 한다. 따라서 space를 더 많이 차지 한다.
<br>Insertion과 Deletion 과정이 조금 더 늘어나게 된다.
<br>Time complexity나, Space Complexity는 Singly linked list와 동일하다.(원리 자체가 동일하기 때문)<br><br>struct CLLNode{
	int data;
	struct CLLNode* Next;
};
Run복사<br>일반적인 노드와 같다는 특징이 있다.<br>
하지만! 중요한 것은 Circular Linked List의 경우에는 Head를 따로 저장하여 관리한다!!<br><br>Next node가 Head와 같은 Node라면 끝에 도달했다는 소리 여기에 일반 Linked list의 중간에 넣는다고 생각해주면 된다.<br><br>Head를 바꿔주고, Head의 Next에 이전 Head를 넣어주면 된다!<br><br>Next Node가 Head인 경우에 그 Node를 삭제하여 Head와 그 이전 노드를 Link한다.<br><br>Head를 가리키는 Temporary 노드를 만든 뒤에 Head 재 설정 후, Temporary node를 삭제한다. ]]></description><link>micro-processor\l4.-recall-c-(part-3).html</link><guid isPermaLink="false">Micro processor/L4. Recall C (Part 3).md</guid><pubDate>Fri, 05 Apr 2024 13:55:26 GMT</pubDate></item><item><title><![CDATA[L5. Recall C (Part 4)]]></title><description><![CDATA[ 
 <br><br>
Stack
<br>Stack은 데이터를 저장하기 위한 간단한 structure로 사용되는데,<br>
<br>Data가 도착한 순서가 중요하다.
<br>데이터가 생성되고 없어지는 것 모두 TOP에서 이뤄진다.
<br>Last in First out (LIFO)
<br><br>
Under flow
<br>텅 빈 stack에서 Pop하려는 것<br>
Overflow
<br>꽉 찬 stack에 Push하려는 것<br><br>
Push
<br>Stack에 element를 삽입하는 과정이다. <br>
POP
<br>Stack에서 element를 제거하는 과정이다.<br>
Top
<br>Top의 데이터를 확인한다.<br>
IsEmptyStack() &amp; IsFullStack()
<br>Stack에 데이터가 비었는가 꽉 찼는가? Overflow와 Underflow 방지<br><br><br>Array기반으로 구현할 때에는 head의 위치를 element가 있는 곳 중 제일 index가  큰 곳으로 지정한다. <br><br>
Disadvantage
<br>
<br>Stack의 Maximum size가 정해져 있어야 한다.
<br>Size가 변경될 수 없다.
<br><br>Push를 진행할 수록 사이즈가 커져야 한다. pop도 마찬가지.<br>
ex). Push를 할 때마다 공간 할당을 위해 복사를 한다고 하면....<br>
	위와 같은 결과를 낼 것이다. 따라서 이를 완화할 방법이 없을까?<br>두 배 씩 늘려보자!!<br>
필요한 공간은 현재는 한번의 Push만 들어와서 한번만 하면 되지만, 현재의 array 크기의 두 배만큼 해주면 어떻게 될까?<br>
당분간은 array의 크기를 늘려주지 않아도 된다.<br>ex). array의 크기는 1부터 시작하고, n =32까지 늘어난다.<br>
공간 할당을 하는 n = 1, 2, 4, 8, 16<br>
<br>예시를 일반화 해보자.<br>
n = 1, 2, 4, 8, ... 일 때에 Copy를 진행한다.<br>
다음과 같은 트릭을 이용하여 이 아닌  으로 연산량을 줄일 수 있다!<br><br>너무 많은 메모리 Doubling은 당연하겠지만 Physical issue로 인하여 overflow가 발생할 수 있음.<br><br>
Push &amp; Pop
<br>Push: Linked List의 Head에서 값을 추가해주면 된다.<br>
Pop: Head를 없애주면 된다.<br><br>유일하게 다른 점은 Delete Stack시에 모든 Node를 일일이 찾아 없애줘야 한다.<br>
Array vs Linked list
<br>Array<br>
<br>operation이 당연하게도 constant time.
<br>Doubling해서 allocation하는 데에 한 번에 조금 공간 점유가 크다.
<br>n개의 operation이 들어오면 O(n)만큼 걸린다.
<br>Linked List<br>
<br>Grows와 Shrink모두 쉽게 Gracefully 구현 가능하다.
<br>모든 operation이 O(1) 만큼의 시간이 걸린다.
<br>모든 operation은 reference를 위해 추가적인 공간과 시간을 사용한다.
<br><br><br>기호의 기우성을 맞추는 데에 사용된다.<br>
ex). ( ), { }, [] 다음과 같이 괄호의 pair가 있고 연산 순서를 따져보면, LIFO의 형태를 따라야 한다.<br>
(a+[b)] : ERROR! LIFO아님!<br>
(a+{b-c}): pair가 맞음! <br><br><br><br><br>
Queue
<br>Queue는 Insertion이 rear에서 이뤄지고, deletion이 front에서 이뤄진다. <br><br>
Enqueue, Dequeue
<br>Enqueue: <br>
<br>queue에 element를 insertion하는 과정
<br>꽉 찬 queue에 Enqueue 하려고 하면 Overflow
<br>Dequeue: <br>
<br>queue에서 element를 제거하는 과정
<br>텅 빈 Queue에서 Dequeue 하려고 하면 Underflow
<br><br>
Front 
<br>가장 앞에 있는 element를 제거 없이 가져온다.<br>
Queue Size 
<br>Queue에 저장된 element의 수를 출력한다, Overflow 방지 가능<br>
isEmptyQueue
<br>비어있는 Queue이지 판별하는 함수, Under flow 방지 가능<br><br>별건 없고 잠깐 동안 대기 해야 하는 대기 열 같은 걸 큐로 말한다.<br>
-&gt; 미국에서도 Is this a line for ~ 하는 거보다 Is this  a queue for ~? 하는 걸 더 잘 알아 듣더라<br><br><br><br>Circular array를 사용하는 이유는 queue에서 rear를 새로 할당하고 front를 버리는 과정을 이용하게 되면, 계속해서 front 부분에서 initial slot이 낭비되는 문제가 생긴다.<br>
<img alt="Pasted image 20240406020645.png" src="lib\media\pasted-image-20240406020645.png"><br>
Enqueue &amp; Dequeue
<br>
<br>Enqueue와 Dequeue를 못하는 상황에서 Exception을 throw한다.
<br>Front 와 Rear가 -1을 가리키면 queue가 비었다는 것이다.
<br><br><br>Dynamic Circular array는 그냥 Doubling trick을 쓴 것을 제외하면 Simple array와 같은 메커니즘이다. <br><br><br>
Enqueue &amp; Dequeue
<br>Enqueue는 linked list의 tail에서 이뤄지고, (rear)<br>
Dequeue는 linked list의 Head에서 이뤄진다.(front)<br><br><br>
definition
<br>Ascending-priority: 가장 작은 키를 가진 요소가 높은 우선도를 가진다.<br>
Descending-priority: 가장 큰 키를 가진 요소가 높은 우선도를 가진다.<br><br>
Insert(key, data)
<br>key value에 따라서, 요소의 oreder를 정하여 priority queue에 삽입한다.<br>
DeleteMin()/DeleteMax()
<br>가장 작은/가장 큰 key의 요소를 반환하면서 지운다.<br>
GetMinimum()/GetMaximum()
<br>가장 작은/ 가장 큰 key의 요소를 반환한다. with out deleting<br>
Auxiliary
<br>k-th smallest/largest : k-th 작은/ 큰 원소를 반환한다.<br>
Size: priority queue의 element 개수를 출력한다.]]></description><link>micro-processor\l5.-recall-c-(part-4).html</link><guid isPermaLink="false">Micro processor/L5. Recall C (Part 4).md</guid><pubDate>Fri, 05 Apr 2024 17:34:59 GMT</pubDate><enclosure url="lib\media\pasted-image-20240406020645.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\pasted-image-20240406020645.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[L6. Recall C (Part 5)]]></title><description><![CDATA[ 
 <br><br>
Classification
<br>
<br>얼마만큼 비교하는가?
<br>교환 횟수
<br>메모리를 얼마만큼 사용하는가?
<br>Recursion이 존재하는가?
<br>Stable한 방법인가?-&gt; stable은 정렬 후 키가 같은 원소들의 순서가 바뀌지 않는 것을 의미
<br>Adaptability? 적응하는 과정
<br><br><br>Basic Version에서는 무조건 n^2번 돌아야한다. <br>for(int i = n-1; i &gt;= 1; i--){
	for(int j = 0; j &lt;= i - 1; j--){
		if(is_swap()?) swap;
	}
}
Run복사<br><br>교환이 더 이상 이뤄지지 않을 때에는 끝내 버린다. Flag가 있음<br>
Improved Version의 경우 한번에 반복문을 나올 수도 있기 때문에,  Complexity가 best case <br>
Performance
<br><br><br>선택정렬: key의 우선순위가 있는 것과 제일 앞에 있는 것을 교체한다. 하나하나 비교를 해봐야 하므로, worst case와 best case모두 .<br>
Performance
<br><br><br>삽입 정렬은 한 칸씩 범위를 확장해 가면서 중간중간에 순서에 맞게 집어넣는 것을 말한다.<br>
<img alt="Pasted image 20240406162937.png" src="lib\media\pasted-image-20240406162937.png"><br>
위의 것 처럼 정렬하는 것을 삽입정렬이라고 하는데, Best case에는 가장 앞에 배치하면 되기 때문에 의 시간 복잡도를 가진다.<br><br><br>Shell sort는 n칸 씩 건너뛰면서 Sorting하고, Adaptive하게 점점 n을 줄이면서 sorting한다. <br>
Properties
<br>
<br>gap sequence 에 따라 향상시킬 수 있는데 어떤 gap sequence를 써야하는지는 아직 정확하진 않음
<br>Adaptive한 방식이라서, 언제 끝날지는 모름.-&gt; 더 빨리 끝날 수 있다는 기대가 있음.
<br>Unstable함
<br><img alt="algorithm Tutorial => Shell Sort Basic Information" src="https://i.stack.imgur.com/WTd9p.jpg" referrerpolicy="no-referrer"><br>void ShellSort(int a[], int n) {
	int i, j, tmp, t;
	for (t = n / 2; t &gt;= 1; t /= 2) { //gap이 t로 정의됨
	//내부 sorting과정 어디는 selection sort, bubble sort인데 여긴 약간 삽입 정렬 느낌
	//상관 없는듯
		for (i = t; i &lt; n; i++) {// t부터 시작해서 점점 증가해나감
			for (j = i - t; j &gt;= 0; j-=t) { //gap이전것들과 하나씩 비교
			
			    if(a[j+t] &gt; a[j]){// 자리 선점 되면 이제 멈춰
			        break;
			    }else{// 아직 새로 들어온것의 자리가 불안전 자리 바꿔줘야 함.
			        tmp = a[j];
			        a[j] = a[j+t];
			        a[j+t] = tmp;
			    }
			}
		}
	}
}
Run복사<br><br><br>Devide and conquer와 굉장히 유사하다. <br>
Procedure
<br>
<br>Divide th array into two parts
<br>Divide the array into two parts again
<br>break into single parts
<br>sort하면서 array합침.
<br>divided arrays합친다.
<br>Merge sort는 반복적인  작업들은 Recursion으로 만들어서 재귀 함수로 만들 수 있다.<br>def MergeSort(arr[], l, r) // target element l~ r까지 중에서

If r &gt; l
	//1. Find Middle point
	middle m = (l+r)/2;
	//2. Call MergeSort
	Call mergeSort(arr, l, m);
	Call mergeSort(arr, m, r);
	//3. 서로 각자 merge sorted된 어레이를 merge하며 sort한다.
	Call merge(arr, l, m, r);
	
Run복사<br>l~m까지 m~r까지는 정렬이 되어있으니,  Merge과정에서 k++해 가면서(arr[k]), l~m에서 가져올지, m~r에서 가져올지 결정하면 된다<br><br><br>하나를 기준으로 하여 양쪽으로 작은 것 큰 것이 나뉜다. 그리고 다시 합쳐진다.<br><img alt="Pasted image 20240406214214.png" src="lib\media\pasted-image-20240406214214.png"><br>
위와 같은 경우가 Quick sort<br>
Best Performance
<br>양 갈래로 정확하게 반반으로 계속 나뉜다면,<br>
시행 횟수 에 대해<br>
마찬가지로<br>
<br>
Worst Performance
<br>만약에 운이 너무 없어서 Pivot을 정했는데 한쪽으로 모든 데이터가 쏠리는 상황이 반복되면..<br>
<br><br>Worst case space complexity는 어떻게 optimize가 가능할까?<br><br>]]></description><link>micro-processor\l6.-recall-c-(part-5).html</link><guid isPermaLink="false">Micro processor/L6. Recall C (Part 5).md</guid><pubDate>Sat, 06 Apr 2024 13:28:38 GMT</pubDate><enclosure url="lib\media\pasted-image-20240406162937.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\pasted-image-20240406162937.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[L7. Introduction to microprocessor]]></title><description><![CDATA[ 
 <br>control system with Electronics = Micro-processor<br><br>
Terminologies
<br>
<br>Integrated Chip (IC)<br>
단일 실리콘 조각에 제작된 전자회로 요소들; 매우 작고, 대량 생산과 비용 절감이 가능하다.
<br>Micro-Controller Unit(MCU)<br>
CPU와 Peripheral, 추가적인 회로와 메모리를 포함하는 IC.
<br>Central Processing Unit (CPU)<br>
프로그램의 instruction을 시행할 수 있는 하드웨어 회로
<br>Instruction<br>
Processor를 실행시키기 위한 명령; Operation과 Operand(없기도 함)로 구성되어있음
<br>Ex. MCU로 Hot plate 기능 구현을 한다고 하자<br>
<br>on/off signal로 간단한 키고 끄기 가능
<br>MCU의 Peripheral인 Sensor가 MCU로 전달하여 적절한 온도 조절 신호를 보낸다.  이 과정에서 Driver에서 신호를 분석하여 조절할 수 있다.
<br><br>
Terminologies
<br>
<br>Peripheral<br>
특별한 기능을 제공하거나 inerfacing하여 CPU를 돕는 hardware; 주변 기기
<br>analog<br>
무한한 값들을 가질 수 있는 것
<br>digital<br>
한정된 수의 값을 가질 수 있는 것
<br>Analog to Digital Converter<br>
Analog value를 상응하는 Digital value로 바꿔주는 회로를 말한다.
<br>Digital to Analog Converter<br>
Digital value를 상응하는 analog value로 바꿔주는 회로를 말한다.
<br><br>
동시성
<br>보통 MCU는 여러가지 작업을 동시에 수행한다.<br>
이런 여러가지 작업을 더하는 것들은 소프트웨어의 복잡성을 증가시킨다.<br>
ex). 메모리 사용량이나, power<br>MCU는 다른 파트의 software를 CPU를 공유하며 사용한다. (interrupt handler와 작업, Thread와 process 등등)<br>
어떤 프로세스는 Peripheral에서 처리가 가능하다.<br>Scheduler<br>
<br>Operating system을 활용하는 필수적인 유닛이다.
<br>Processor에 다음에 처리해야 할 소프트웨어 조각을 결정해준다.
<br>Performance가 높을 수록 가격 비쌈
<br><br>
Responsiveness(응답성)
<br>주어진 시간 내에 할당된 작업을 완료하는 시스템 또는 기능적 단위<br>
Responsiveness를 높이기 위해서<br>
<br>Raw processing Speed<br>
Code를 Optimize하고, 빠른 CPU를 사용한다.
<br>Task Scheduling<br>
중요한 작업에서는 focus하는 것이 중요하다.
<br>Multicore processing
<br>Multiple processors
<br><br>당연하게도, 사용자는 프로그램이 도중에 끊기는 것을 예상하지 못한다.<br>
현재에 Failure가 있어도 그 영향을 최소화 시켜줘야한다.<br>Failure를 Detect할 때에는 run time이나 과거를 분석할 때에 센서를 사용.<br>
Unexpected cases에 대한 software routine이 이미 정해져 있음.<br>
-&gt;Diagnostic을 통해 fault가 어디서 발생했는지 알 수 있는 것<br><br>Arm Cortex-M0+를 수업 시간에 사용한다.<br>
Memory와 소통을 통해  instruction과 data를 얻어낸다<br>
Feature
<br>
<br>Memory 접근할 때에, CPU는 AHB-Lite interface로 소통하는데, memory는 바깥에 배치해 있는 경우도 있다.(이 경우에는 바깥에 있음)
<br>Interrupt handler는 CPU에 명령이 들어가는 것보다 먼저 처리 해야함. 따라서 Processor core에 붙어있는 Nested Vecotred Interrupt Controller를 사용하여 Interrupt할 수 있도록 한다. 
<br><br><img alt="Pasted image 20240406231120.png" src="lib\media\pasted-image-20240406231120.png"><br>
High speed Bus에는 일단 CPU, Memory, GPIO(HMI), System; 가장 접근성이 높은 것이 연결되어있다.<br>
Peripheral Bus에는 주변 기기들..<br>
헷갈릴 수 있는 것은 Clock이 Peripheral이라는 것이다.]]></description><link>micro-processor\l7.-introduction-to-microprocessor.html</link><guid isPermaLink="false">Micro processor/L7. Introduction to microprocessor.md</guid><pubDate>Sat, 06 Apr 2024 14:19:21 GMT</pubDate><enclosure url="lib\media\pasted-image-20240406231120.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\pasted-image-20240406231120.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[L8. ARM Cortex-M0(+) Core (Part 1)]]></title><description><![CDATA[ 
 <br><img alt="Pasted image 20240406231120.png" src="lib\media\pasted-image-20240406231120.png"><br><br><br>
instruction
<br>Processor를 실행시키는 명령어, Operator와 Operand로 이뤄져 있다. (Operand는 없을 수도)<br>
Operation
<br>instruction의 부분으로 어떤 작업을 할 것인지 특정 해준다.<br>
Operand
<br>instruction의 부분으로 Operation에 의해 사용되는 Parameter다.<br><br><img alt="Pasted image 20240406233648.png" src="lib\media\pasted-image-20240406233648.png"><br>
Architecture의 종류
<br>Harvard Architecture: Program Memory와 Data Memory 나눠져 있다.<br>
Von neumann Architecture: 둘은 하나.<br>위의 예시는 Harvard Architecture인 것을 알 수 있다.<br><br>
Program Memory (PM)
<br>Sequence of Instructions 가 저장되어있는 곳<br>
Program Counter (PC)
<br>PC는 Register인데 PM에서 다음 instruction의 주소를 가리키고 있는 특별한 목적의 레지스터다.<br>
ALU (Arithmetic / Logical Unit)
<br>data processing operation이 이뤄지는 곳. Addition이나, Substraction, logic operation, Compare, etc.<br>
Register File
<br>중간 단계의 저장소로 ALU process를 위하여 일시적으로 값을 가지고 있다.<br>
빠르게 접근이 가능하다. 하지만, 작은 용량..<br>
Data Memory (DM)
<br>Long-term Data 저장소로, 훨씬 큰 데이터를 저장한다.<br>
접근하기 어렵고 느리다. <br>
Control Logic
<br>Decode Fetched instruction into control data sequence<br><br>Processor마다 각자 가지고 있는 행동이 정의된다. <br>
<br>Programmer's model: operating modes, registers, memory map
<br>Instruction set architecture: instructions, addressing modes, data type
<br>Exception Handling: interrupt handling
<br>Debug Architecture: Debug features
<br>우리가 사용할 ARM cortex-M0+ processor(32-bit)의 경우에는 ARMv6M Architecture를 적용한다.<br>
특징<br>
1. register file에 있는 data만 process될 수 있다.<br>
2. DM에 있는 Data는 직접적으로 접근이 불가능하고, load를 통하여 register file을 processing한 후에, 나중에 저장할 일이 있으면, store instruction을 통해 DM에 저장한다. <br><br><img alt="Pasted image 20240407165810.png" src="lib\media\pasted-image-20240407165810.png"><br><br>Multiple 32-bit registers가 있다. (R0 ~ R15)<br>
각자 특정한 역할이 있다.<br>
General Purposed Registers
<br>R0~ R12: General Purposed registers for data procssing<br>
R13: Stack pointer (SP)<br>
R14: Link Register (LR; Holding the return address)<br>
R15: PC(Holding the address of the next instruction)<br>
Special Purposed Register (SPR)
<br>
<br>
Program Status Register (PSR)

<br>Application PSR (APSR): code flag를 보여준다. (N, Z, C, V 상위 4bit) 
<br>Interrupt PSR (IPSR): exception number를 가지고 있다. (하위 6 bit)
<br>Execution PSR (EPSR): 간혹 보다 보면, 32bit, 16bit를 둘 다 쓰는데, EPSR[24] bit를 이용하여, Thumb모드 전환을 통해 전환 가능

condition flag<br>
N(negative),  Z(zero), C(carry), V(overflow)<br>


<br>
PRIMASK register<br>
interrupt의 종류 중 MASKING을 통하여 어떤 interrupt를 작동하게 할 수 있을 지 고른다.

<br>
CONTROL register<br>
SPSEL이라 불리는 파트가 stack pointer 가 사용되었는지 확인시켜줌.

<br><br>ARMv6-M architecture에서는 32bit의 주소 addressing공간이 있다. 따라서 개의 위치를 표현 가능하다. 하나의 주소 당 1byte를 가리키기 때문에, 2^32개의 addressing이 가능하다.<br>Memory space는 사용처에 따라 다양한 영역으로 나눠지게 된다. <br><br>
least significant byte
<br>가장 작은 부분의 byte 0~255의 값을 지닌다.<br>
little endian
<br>least significant byte 가 메모리의 제일 앞(Lowest memory address)에 배치된다.<br><br>
most sinificant byte
<br>가장 높은 값을 가지는 위치. 0~65280의 값을 가진다. <br>
big endian
<br>most significant byte가 메모리의 제일 앞(Lowest memory address)에 배치된다. <br><br>ARMv6-M architecture는 항상 little endian사용]]></description><link>micro-processor\l8.-arm-cortex-m0(+)-core-(part-1).html</link><guid isPermaLink="false">Micro processor/L8. ARM Cortex-M0(+) Core (Part 1).md</guid><pubDate>Sun, 07 Apr 2024 12:48:10 GMT</pubDate><enclosure url="lib\media\pasted-image-20240406231120.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\pasted-image-20240406231120.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[L9. ARM Cortex-M0(+) Core (Part 2)]]></title><description><![CDATA[ 
 <br><br><br>Instruction은 주로 machine language나 assembly language로 나타낼 수 있다.<br>
machine language
<br>숫자로 나타나는 Code. CPU에 의하여 바로 Process할 수 있다.<br>
assembly language
<br>machine code를 사람이 읽을 수 있도록 표현한 것<br>
assembler
<br>compiler는 software tool로 seembly language code를 machine code로 바꿔주는 역할을 한다. <br><br>
MOV/MOVS
<br>
<br>
MOV<br>
MOV는 값을 복사하는 역할을 한다. format이 두 가지 있는데, 
MOV R3, R5    @ R5의 값을 R3에 복사한다.
MOV R2, #151  @ 151을 R2에 복사한다.
복사
Immediate하게 값을 복사하는 것은 0~255 까지 밖에 하지 못한다. 

<br>
MOVS는 같은 동작을 하는 Instruction이지만, SPR의 <a data-tooltip-position="top" aria-label="L8. ARM Cortex-M0(+) Core (Part 1) > ^aaa382" data-href="L8. ARM Cortex-M0(+) Core (Part 1)#^aaa382" href="micro-processor\l8.-arm-cortex-m0(+)-core-(part-1).html#^aaa382" class="internal-link" target="_self" rel="noopener">APSR 중 N, Z flag</a> 를 업데이트 시킨다.

<br>
MRS/MSR
<br>Special Register와 General Purposed Register의 복사를 위해 존재하는 Instruction<br>
<br>MRS: Special Register -&gt;General Purposed Register
<br>MSR: General Purposed Register -&gt; Special Register
<br><br>한 개 이상의 32 bit 데이터 값에 초점을 맞춘다.<br>
주로, 1. 두 개의 Register를 operand로 사용하거나, 2. 한개의 Reigster와 immediate value를 사용한다.<br><br>Addition이나, Subtraction등의 operation을 한다.<br>
Ex).<br>ADDS R0, R1, R2 @ R0 = R1 + R2; n, z, c, v 저장 
복사<br><br>Bitwise로 연산을 하거나 Exclusive연산 등등 다양한 Logic operation을 한다.<br>
Ex).<br>ANDS R0, R1, R2 @ R0 = R1 &amp; R2; n, z, c, v 저장 
복사<br><br>다른 두 operand를 비교하여 연산하고, condition code flag를 바꾸지만, 계산된 difference는 버린다.<br>
Ex).<br>CMP R3, R5 @ R3-R5를 하여 이에 따른 N, Z, C, V값을 APSR에 저장
           @ R3 = #2, R5 = #2 일떄, N = 0, Z = 1, C = 1, V= 0; carray는 확실하지 않음
복사<br><br>
Arithmetic Shift
<br>부호의 유지가 중요. Most significant bit의 부호를 유지 시키도록 ASRS를 한다. (MSb 복사)<br>
Logical Shift
<br>Logical Shift는 그냥 어느 방향으로 밀던 0을 추가한다.<br>
Rotational Shift
<br>Rotaion을 하는 Shift 빠진 값이 Circular 하게 다시 들어온다.<br>Ex).<br>LSRS R1, #1 @ 오른쪽으로 한칸 밀며, MSB엔 0이 들어온다.
ASRS R1, #1 @ 오른쪽으로 한칸 밀며, MSB엔 MSB에 있던 값이 복사된다.
복사<br><br>bit수가 다른 Register를 이용할 때 사용하거나, 자료형이 다를 때 사용한다. <br>
<br>Unsigned Extension: UXTB, UXTH
<br>Signed Extension: SXTB, SXTH
<br><br>Big endian -&gt; Little endian or Little endian -&gt; Big endian일 때 주로 사용한다.<br><br>
Memory Addressing을 하는 방법
<br>
<br>[R0]
<br>[R0, #22]
<br>[R0, R3]
<br><br>LDR과 STR로 크게 두 가지로 나뉜다. 4개의 memory location이라는 것은 하나의 memory address가 표현하는 것은 byte이고, 4개가 있어야 비로소 32bit에 대한 접근이 가능하기 때문이다.<br>
LDR
<br>32bit(word)를 4개의 memory location으로 가져오는 역할을 한다.<br>
STR
<br>32bit의 컨텐츠를 4개의 memory location에 저장하는 역할을 한다.<br>LDR R0, [R4, #8]
STR R1, [R4, R5]
복사<br> 작은 사이즈의 데이터 (less than 32bits): STRB, STRH, LDRB, LDRH, LDRSB, LDRSH<br><br>
Push
<br>선택된 최대 4개의 Register들을 stack에 쌓는다. <br>
POP
<br>최대 두 개의 Register에 Stack의 pop을 통해 데이터를 가져온다.<br>PUSH{R0, R5-R7} @4개의 데이터 밀어넣기
SUB SP, SP, #16 @SP Lowest address가 바뀜 빼줘야함. Address 한개 당 1byte
POP{R2, R4} @ 2개의 데이터 POP
ADD SP, SP, #8 @Lowest address가 바뀜 더해줘야함.
복사<br><br>프로그램이 조건에 따라 루프를 돌거나 원하는 코드를 조건에 따라 실행할 수 있도록 하기 위해서 PC의 값을 다른 값으로 변화 시켜, 특정 Instruction을 수행하도록 한다.<br><br>Target_label:
	@...

B Target_label @ Target_label로 돌아감.
복사<br><br>CMP R1, R2 
BEQ Target_label
BNE Target_label
BGT Target_label
BGE Target_label
BLT Target_label
BLE Target_label
복사<br>APSR의 N, Z, C, V 의 값을 이용하여 각각의 Instruction에 맞는 조건인지 판별할 수 있다.<br>
Ex).<br>
<br>EQ: Z = 1
<br>NE: Z = 0
<br>LT: N!= V ; Negative이고 Overflow가 인 경우, Negative가 아니지만, Overflow여서 Negative값을 가지는 것
<br>GT: Z = 0 and N=V
<br>LE: Z = 1 or N != V
<br>GE: N = V
<br><br>BL Subroutine
BLX R0
복사<br>
Subroutine call
<br>BL: Branch and link<br>
BLX: Branch and link with Arm <a data-tooltip-position="top" aria-label="L8. ARM Cortex-M0(+) Core (Part 1) > ^97163a" data-href="L8. ARM Cortex-M0(+) Core (Part 1)#^97163a" href="micro-processor\l8.-arm-cortex-m0(+)-core-(part-1).html#^97163a" class="internal-link" target="_self" rel="noopener">Thumb 전환</a><br>Subroutine call이 실행되면, LR에 return address가 저장된다. <br>Nested Subroutine call이 실행된다면, (재귀 함수) LR은 Stack형태가 아니라 레지스터이기 때문에, Stack에 LR을 PUSH하고 다른 Function을 Call한 뒤 return 후에 POP하여 LR을 복원해야 한다.<br><br>
Control PRIMASK
<br>allow되는 Interrupt와 Exception 설정<br>
CPSID, CPSIE<br>
NOP
<br>아무것도 하지 않고 Cycle을 버린다. Pipelining을 진행할 때에 Branch prediction으로 진행하고 있던 Instruction을 모두 FLUSH하고 다음 Instruction이 들어오기 까지 기다린다.<br>
ETC
<br>Debugging, Exceptions, Sleep mode, Complex memory System, Signaling...]]></description><link>micro-processor\l9.-arm-cortex-m0(+)-core-(part-2).html</link><guid isPermaLink="false">Micro processor/L9. ARM Cortex-M0(+) Core (Part 2).md</guid><pubDate>Sun, 07 Apr 2024 12:53:35 GMT</pubDate></item><item><title><![CDATA[L10. C in Assembly Language]]></title><description><![CDATA[ 
 <br><img alt="Pasted image 20240407215352.png" src="lib\media\pasted-image-20240407215352.png"><br>
Compiler, Assembler, Linker/Loader
<br>C코드가 컴파일 되는 과정을 위에서 볼 수 있다.<br>
<br>Source File이 컴파일러를 통하여 Assembly File이 된다.
<br>Assembler를 통해 CPU가 알아볼 수 있는 Binary Object File들을 만든다. 
<br>Linker/Loader에서 Object로 변환한 여러 파일들이나 라이브러리 파일들을 연결하여, 실행 가능한 파일을 만든다. 
<br><br>사람이 읽을 수 있는 assembly language module을 object module으로 변환 시켜 준다. <br><br><img alt="Pasted image 20240407230031.png" src="lib\media\pasted-image-20240407230031.png"><br>
Fuction Arguments
<br>R0~R3: Function Arguments로 쓰인다. 이들은 Stack에 넣어야 할 필요가 없다.<br>
Function Return
<br>R0: 32bit value에 대해서는 R0를 Return Register로 사용한다.<br>
(R0,R1) : 64bit value에 대해서 R0와 R1을 묶어 Return Register로 사용한다.<br>
Stack: 더 긴 Return의 경우에는 Stack을 사용한다. <br><br><br>사용되었던 Register들을 Stack에 넣는다.<br>
Initializing automatic variables<br><br>올바른 위치에 return value를 넣는다.<br>
보존된 Register를 원래의 값으로 복원한다.<br>
calling function의 위치로 돌아간다. ]]></description><link>micro-processor\l10.-c-in-assembly-language.html</link><guid isPermaLink="false">Micro processor/L10. C in Assembly Language.md</guid><pubDate>Sun, 07 Apr 2024 14:12:17 GMT</pubDate><enclosure url="lib\media\pasted-image-20240407215352.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\pasted-image-20240407215352.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[L11. Arithmetic for computers (Part 1)]]></title><description><![CDATA[ 
 <br><br>computer는 주로  Binary를 사용하기 때문에 Binary number로 변환해 줘야한다. <br><br>각 자리 수는 2의 power들이다. 따라서, 10진법으로 변할 때는 각 자리수의 숫자에 Power of 2를 곱해주어 더해주면 된다.<br><br><br><br><br>
Binary -&gt; Hexadecimal
<br>Binary에서 Hexadecimal로 변환할 때에는 4칸씩 끊어서 보면 된다.<br>
ex). 0010 0110 1101 1001 (2) -&gt; 26D9 (16)<br>
Hexadecimal -&gt; Binary
<br>Hexadecimal에서 Binary로 변환할 때에는 한 letter = 4bit 씩 변환하면 된다.<br><br>
Bits
<br>숫자 하나.<br><br>Most Significant Bits, Least Significant BIts<br>
Bytes &amp; nibble
<br><br>
MSB
<br><br><br>
Sign bit in most significant bit
<br>
<br>
Positive는 0, Negative는 1<br>
Ex). +6 = 0110, -6 = 1110

<br>
Range: [-(-1), (-1)]

<br>
Probelm: 연산이 불가능함. 

<br><br>
Two's complement
<br>
<br>Sign bit로 나타내는 것의 단점인 연산이 불가능하다는 것을 보완
<br>2의 보수 체제를 활용한다.
<br>
Overflow
<br>문제는  Overflow가 발생할 수 있다는 것이다. Overflow는 연산 결과가 bit로 표현할 수 있는 범위를 넘어가게 되면 발생하게 된다. <br>Carry와 MSB가 같으면 문제가 발생하지 않는다.  Carry와 MSB가 다르면 Overflow<br>
Overflow의 해결
<br>Bit수를 더 키우면 수의 표현 범위가 넓어지기 때문에 Overflow 문제를 피할 수 있다.<br>
따라서 Sign Extension과 Zero Extenstion이 필요하다.<br><br>
Sign Extension
<br>Most significant bit를 복사하여 expand한 자리 수 만큼 연장한다.<br>
Zero Extension
<br>Most significant에 0을 배치하기 위한 방법. Unsinged 에 사용된다.<br><br>Graphic이나 Media를 처리할 때에는 vector로 한번에 16bit, 8bit씩 연산하는 경우가 있다.<br>
<br>이때는 64bit adder를 사용하는데, 8*8-bit, 4*16 bit, 2*32 bit 이렇게 나눠서 사용한다.
<br>SIMD(Single Instruction Multiple data)라는 방법이다.
<br>Overflow를 방지하기 위하여 큰 값들은 일부러 조정한다. <br>
<br>clipping adudio, saturation in video
<br><br><br><img alt="Pasted image 20240408002207.png" src="lib\media\pasted-image-20240408002207.png"><br>
<br>Product (64 bit) initialize to 0
<br>Multiplicand (32 bit -&gt; 64 bit extension)와 Multiplier initialize
<br>Multiplicand 64bit를 ALU로 내려보낸다. 
<br>Product 와 Multiplicand를 더할지 Multiplier의 lsb에 따라 결정한다.
<br>Multiplicand shift left한다. 
<br>Multiplier Shift Right한다.
<br>32번의 shift가 모두 끝났다면 8, 아니라면 3번으로 이동한다.
<br>Product에 최종적으로 결과가 저장된다.<br>
이 모든 것을 관장하는 것은 Control test.
<br><br>비슷한 과정인데 Multiplier와 Product를 합치고 Multiplicand를 Shift left를 Product의 right shift로 대체한다.<br>
<img alt="Pasted image 20240408003709.png" src="lib\media\pasted-image-20240408003709.png"><br><br>Multiple Adder를 이용하여 만들 수 있다. Multiplier의 각 자리 비트를 Multiplicand와 곱한다. 32bit adder면 충분하다.  Cost performance의 Trade off가 존재한다<br>
<img alt="Pasted image 20240408161112.png" src="lib\media\pasted-image-20240408161112.png"><br>
<img alt="Pasted image 20240408161135.png" src="lib\media\pasted-image-20240408161135.png" style="width: 500px; max-width: 100%;"><br>
하지만 위의 경우에는(4bits) 제대로 연산이 되지 않는데 한번 확인해볼 필요가 있을 것 같다...<br><br>Devider hardware는 아래와 같다.<br>
<img alt="Pasted image 20240408161708.png" src="lib\media\pasted-image-20240408161708.png" style="width: 500px; max-width: 100%;"><br>
Remainder가 음수가 되지 않도록 계속해서 Control하고, Divisor를 2로 계속해서 나눠서 Remainder에서 Divisor를 빼준다. 이때 값이 빼졌는지를 Quotient에 shift left하며 넣어준다. <br><br><img alt="Pasted image 20240408162850.png" src="lib\media\pasted-image-20240408162850.png"><br>
마찬가지로 Remainder를 두 부분으로 나눠서 Remainder에 Divisor와 Quotient를 넣을 수 있다. Remainder를 left shift, Quotient는 Right shift? Quotient도 Shift left 해야 하지 않나...?? <br><br>그런 거 없다. 조건 하에 뺄셈이 필요하기 때문에 안된다.]]></description><link>micro-processor\l11.-arithmetic-for-computers-(part-1).html</link><guid isPermaLink="false">Micro processor/L11. Arithmetic for computers (Part 1).md</guid><pubDate>Mon, 08 Apr 2024 07:35:45 GMT</pubDate><enclosure url="lib\media\pasted-image-20240408002207.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\pasted-image-20240408002207.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[L12. Arithmetic for computers (Part 2)]]></title><description><![CDATA[ 
 <br><br><br>Float는 very small한 값부터 very large한 값까지 나타내야한다.<br>
Noramalize함으로써 가능.<br>
IEEE-754
<br>(Sign, Exponent, Mantissa)<br>
Single Precision: (1,8, 23)<br>
Double Precision: (1, 11, 52)<br>Binary의 floating point format은<br>
Bias는 Single Precision에선 127, Double Precision에선 1023<br><br>Exponent 00000000 and 11111111 Reserved already<br>
Smallest Value
<br>Exponent = 00000001 = 1<br>
Bias = 127<br>
actual exponent = -126<br>
<br>
Largest Value
<br>Exponent = 11111110 = 254<br>
Bias = 127<br>
actual exponent = 127<br>
Mantissa = 1111...11<br>
<br>
Precision
<br>Mantissa = 23bit<br>
precision =  <br>
digit = 6<br><br>Exponent 00000000000 and 11111111111 Reserved already<br>
Smallest Value
<br>Exponent = 00000000001 = 1<br>
Bias = 1023<br>
actual exponent = -1022<br>
<br>
Largest Value
<br>Exponent = 11111111110 = 2046<br>
Bias = 1023<br>
actual exponent = 1023<br>
Mantissa = 1111...11<br>
<br>
Precision
<br>Mantissa = 52bit<br>
precision =  <br>
digit = 16<br><br>Exponent 000...0, 111...1 이 예약 되어 있다고 말했었다. <br>
Exponent = 000...0
<br>
<br>Mantissa 앞의 저장된 1이 없어지고, Exponent = 0<br>

<br>따라서 더 작은 값이나 0을 표현할 수 있다.
<br>
Exponent = 111...1
<br>
<br>with fraction  =  000...00<br>
infinite
<br>with fraction !=  000...00<br>
Not a Number -&gt; Undefined result
<br><br><br>
<br>Align Binary Points<br>
소수점의 위치를 먼저 일치 시켜야 한다. 따라서 Exponent 파트를 조정하고 그만큼 Mantissa도 shift시킨다. (이때 Exponent의 절대값이 낮은 쪽으로 일치시킨다.)
<br>Add Significands<br>
{1, Mantissa} 끼리 연산을 한다. floating point 
<br>Normalize result &amp; check for over/under flow<br>
IEEE-754 format으로 다시 바꾸기.
<br>Round and renormalize if neccesory<br>
반올림이나, renormalize  필요하면 하기
<br><br>
<br>Add exponents

<br>Unbiased : -1 + -2 = -3
<br>Biased: (-1+127)+ (-2+127) -127 = -3 + 127


<br>Multipy significands
<br>Normalize result &amp; check for over/under flow
<br>Round and renormalize if neccessary
<br>Determine Sign
<br><br><br>Graphic이나 오디오 같은 경우에는 Vector operation으로 연산 이득을 볼 수 있다.<br>
Ex). 128 bit adder를 이용해 짧은 vector의 같은 연산을 한번에 진행할 수 있다.<br>
이렇게 Vector operation으로 Parallel한 연산을 수행하는 것을 <br>
<br>Data-level parallelism
<br>vector parallelsim
<br>Single Instructioin Multiple Data (SIMD)<br>
라고 부른다.
<br><br>32 128-bit registers (V0, ...,V31)까지 있다.<br>
Integer와 Floating point모두 동작한다.<br>Ex). <br>
<br>
16 8bit integer adds:<br>
ADD V1.16B, V2.16B, V3.16B

<br>
4 32bit integer adds:<br>
FADD V1.4S, V2.4S, V3.4S

<br>
SIMD instructions이 245개나 있음
<br>
<br>Square root
<br>Fused multiply-add, multiply-subtract
<br>Conversion and scalar and vector round to integral
<br>Strutured vector load stores
<br>Saturating arithmetics
<br>
SSE2(Streaming SIMD Extensioin 2)
<br>Adds 4x128-bit registers (AMD 64같은 64bit컴퓨터에서 사용하는 듯)]]></description><link>micro-processor\l12.-arithmetic-for-computers-(part-2).html</link><guid isPermaLink="false">Micro processor/L12. Arithmetic for computers (Part 2).md</guid><pubDate>Mon, 08 Apr 2024 11:09:54 GMT</pubDate></item></channel></rss>